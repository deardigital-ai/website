name: Code Analysis and Issue Creation

on:
  schedule:
    - cron: '*/5 * * * *'  # Run every 5 minutes
  workflow_dispatch:  # Allow manual triggering

jobs:
  analyze-code:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get codebase files
        id: codebase-files
        run: |
          # Get all code files in the repository
          CODE_FILES=$(find . -type f -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.py" -o -name "*.go" -o -name "*.java" -o -name "*.rb" -o -name "*.php" -o -name "*.c" -o -name "*.cpp" -o -name "*.h" -o -name "*.hpp" -o -name "*.cs" | sort)
          
          if [ -z "$CODE_FILES" ]; then
            echo "No code files found in the repository."
            echo "has_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Save the last analyzed commit for tracking purposes only
          git rev-parse HEAD > ".last_code_analysis_run"
          
          # Randomly select up to 5 files to analyze in this run
          # This prevents analyzing the entire codebase every 5 minutes
          SELECTED_FILES=$(echo "$CODE_FILES" | shuf -n 5)
          
          echo "has_files=true" >> $GITHUB_OUTPUT
          
          # Save the list to an output variable
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$SELECTED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Analyze codebase
        id: code-analysis
        if: steps.codebase-files.outputs.has_files == 'true'
        run: |
          # Get the list of files to analyze
          SELECTED_FILES="${{ steps.codebase-files.outputs.files }}"
          
          # Get repository structure for context
          REPO_STRUCTURE=$(find . -type f -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.py" -o -name "*.go" -o -name "*.java" -o -name "*.rb" -o -name "*.php" -o -name "*.c" -o -name "*.cpp" -o -name "*.h" -o -name "*.hpp" -o -name "*.cs" | sort)
          
          # Create the prompt text
          PROMPT_TEXT="You are an expert code analyzer. Analyze the following repository structure and selected files to identify potential features, bugs, and improvements.

          Repository Structure (partial):
          $REPO_STRUCTURE

          Selected Files for Analysis:
          $SELECTED_FILES

          For each file, I will provide the content. Based on your analysis, suggest:
          1. New features that could enhance the codebase
          2. Potential bugs or issues that need fixing
          3. Code improvements for better performance, readability, or maintainability

          You have complete freedom to suggest any improvements you think would be valuable, regardless of when the files were last changed.

          Format your response as a JSON array with the following structure:
          [
            {
              \"type\": \"feature\"|\"bug\"|\"improvement\",
              \"title\": \"Brief, descriptive title\",
              \"description\": \"Detailed description of the issue\",
              \"priority\": \"high\"|\"medium\"|\"low\",
              \"related_files\": [\"file1\", \"file2\"]
            },
            ...
          ]

          Limit your suggestions to the 3-5 most important ones. Be specific and actionable."
          
          # Initialize suggestions array
          SUGGESTIONS="[]"
          
          # Process each file
          for FILE in $SELECTED_FILES; do
            if [ ! -f "$FILE" ]; then
              echo "File $FILE no longer exists, skipping"
              continue
            fi
            
            echo "Analyzing $FILE"
            
            # Get file content
            FILE_CONTENT=$(cat "$FILE")
            
            # Create file-specific prompt
            FILE_PROMPT="Analyzing file: $FILE

            ```
            $FILE_CONTENT
            ```

            Based on this file and the repository context, suggest potential features, bugs, or improvements. Be creative and thorough in your analysis."
            
            # Create JSON payload for Ollama
            JSON_PAYLOAD="{\"model\": \"qwq:latest\", \"prompt\": $(echo "$PROMPT_TEXT\n\n$FILE_PROMPT" | jq -Rs .), \"stream\": false}"
            
            # Call Ollama API to analyze code
            FILE_ANALYSIS=$(curl -s -H "Content-Type: application/json" \
              -d "$JSON_PAYLOAD" \
              http://localhost:11434/api/generate | jq -r '.response' | \
              # Filter out <think> tags and their content
              sed -E 's/<think>.*<\/think>//g')
            
            # Extract JSON array from response (handling potential text before/after JSON)
            FILE_SUGGESTIONS=$(echo "$FILE_ANALYSIS" | grep -o '\[.*\]' || echo "[]")
            
            # If no valid JSON found, try to extract from markdown code blocks
            if [ "$FILE_SUGGESTIONS" = "[]" ]; then
              FILE_SUGGESTIONS=$(echo "$FILE_ANALYSIS" | grep -o '```json\s*\[.*\]\s*```' | sed 's/```json//g' | sed 's/```//g' || echo "[]")
            fi
            
            # Ensure we have valid JSON
            if ! echo "$FILE_SUGGESTIONS" | jq empty 2>/dev/null; then
              echo "Invalid JSON response for $FILE, skipping"
              continue
            fi
            
            # Merge with existing suggestions
            if [ "$SUGGESTIONS" = "[]" ]; then
              SUGGESTIONS="$FILE_SUGGESTIONS"
            else
              SUGGESTIONS=$(echo "$SUGGESTIONS" "$FILE_SUGGESTIONS" | jq -s 'add | unique')
            fi
          done
          
          # Save the suggestions to an output variable
          echo "suggestions<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTIONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub issues
        if: steps.codebase-files.outputs.has_files == 'true'
        uses: actions/github-script@v6
        env:
          SUGGESTIONS: ${{ steps.code-analysis.outputs.suggestions }}
        with:
          github-token: ${{ secrets.PAT }}  # Use custom PAT instead of default GITHUB_TOKEN
          script: |
            const suggestions = JSON.parse(process.env.SUGGESTIONS || '[]');
            
            if (!suggestions.length) {
              console.log('No suggestions to create issues for');
              return;
            }
            
            // Define issue templates for each type
            const issueTemplates = {
              feature: {
                title: '✨ Feature: {title}',
                body: `## Feature Request\n\n**Description**\n{description}\n\n**Priority**\n{priority}\n\n**Related Files**\n{related_files}\n\n---\n*This issue was automatically generated by the code analysis system.*`
              },
              bug: {
                title: '🐛 Bug: {title}',
                body: `## Bug Report\n\n**Description**\n{description}\n\n**Priority**\n{priority}\n\n**Related Files**\n{related_files}\n\n---\n*This issue was automatically generated by the code analysis system.*`
              },
              improvement: {
                title: '🔧 Improvement: {title}',
                body: `## Improvement Suggestion\n\n**Description**\n{description}\n\n**Priority**\n{priority}\n\n**Related Files**\n{related_files}\n\n---\n*This issue was automatically generated by the code analysis system.*`
              }
            };
            
            // Process each suggestion
            for (const suggestion of suggestions) {
              try {
                const template = issueTemplates[suggestion.type];
                if (!template) {
                  console.log(`Unknown suggestion type: ${suggestion.type}`);
                  continue;
                }
                
                // Format related files as a list
                const relatedFiles = suggestion.related_files && suggestion.related_files.length 
                  ? suggestion.related_files.map(file => `- \`${file}\``).join('\n')
                  : 'None specified';
                
                // Create the issue
                const title = template.title.replace('{title}', suggestion.title);
                const body = template.body
                  .replace('{description}', suggestion.description)
                  .replace('{priority}', suggestion.priority || 'medium')
                  .replace('{related_files}', relatedFiles);
                
                // Check if a similar issue already exists (to avoid duplicates)
                const existingIssues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 100
                });
                
                const similarIssueExists = existingIssues.data.some(issue => 
                  issue.title.toLowerCase().includes(suggestion.title.toLowerCase())
                );
                
                if (similarIssueExists) {
                  console.log(`Similar issue already exists for: ${suggestion.title}`);
                  continue;
                }
                
                // Create the issue
                const response = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  labels: [suggestion.type, suggestion.priority || 'medium']
                });
                
                console.log(`Created issue #${response.data.number}: ${title}`);
              } catch (error) {
                console.error(`Error creating issue for suggestion: ${suggestion.title}`, error);
              }
            } 